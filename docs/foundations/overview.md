# 알고리즘 기초: 시간 복잡도·점근 표기·분할정복

## 1. 알고리즘의 역할(The Role of Algorithms)
- **핵심**: 동일한 하드웨어에서도 알고리즘 선택에 따라 성능이 **지수적 차이**가 난다.   
문제 해결의 **정확성(cor\-rectness)**, **효율성(efficiency)**, **견고성(robustness)** 이 평가 기축이 된다.
- **비용 모델**: 원시 연산(비교, 대입, 산술)의 개수를 입력 크기 `n`의 함수로 근사. 상수·낮은 차수 무시(점근 분석).

### 1.1 알고리즘(Algorithm)
- **정의**: 유한한 명령의 순서로, 모든 유효 입력에서 **유한 시간 내** 종료하며 요구된 출력을 산출하는 절차.
- **요건**: 명확성, 올바름, 유한성, 결정성, 입력·출력 명시.

### 1.2 기술로서 알고리즘(Algorithm as Technology)
- **관점**: 하드웨어·데이터·개발공수와 함께 **알고리즘 자체가 기술**.  
대규모 데이터/서비스에서 비용 절감의 핵심 레버.
- **예**: 정렬·탐색·그래프·암호·수치 계산·머신러닝, 캐시/병렬성 고려한 설계.

---

## 2. 시작하기(Getting Started)

### 2.1 삽입 정렬(Insertion Sort) — 간단한 분석
- **아이디어**: `A[0..j-1]`이 정렬되어 있다고 가정하고 `A[j]`를 올바른 위치에 삽입.
- **의사코드(0-기반)**
```text
INSERTION_SORT(A):
  for j ← 1 to n-1:
    key ← A[j]
    i ← j - 1
    while i ≥ 0 and A[i] > key:
      A[i+1] ← A[i]
      i ← i - 1
    A[i+1] ← key
```
- **루프 불변식**: 바깥 루프 시작 시마다 `A[0..j-1]`는 정렬됨.
  - **초기화**: `j=1`에서 자명.  
  - **유지**: 내부 while이 `key`의 삽입 위치를 찾아 정렬 유지.  
  - **종료**: `j=n`이면 전체 정렬.
- **시간 복잡도**: 최악·평균 `Θ(n^2)`, 최선(이미 정렬) `Θ(n)`.
- **공간**: 제자리(in-place) `Θ(1)`.

### 2.2 알고리즘의 분석(Analysis)
- **입력 크기** `n`과 **실행 시간 함수** `T(n)` 정의.
- **최악/평균/최선** 케이스 구분. 평균은 입력 분포에 의존.
- **점근 표기**로 상수·낮은 차수 제거 → 성장률 비교.

### 2.3 알고리즘의 설계(Design)
- 주된 패러다임: **분할정복(divide\-and\-conquer)**, **동적 계획법(DP)**, **그리디**, **무작위화** 등.

### 2.4 분할정복 개요(Overview of Divide‑and‑Conquer)
- **형식**: 문제를 균등/비균등 부분문제로 **분할(divide)** → 부분문제를 **정복(conquer)** → 해를 **결합(combine)**.
- **전형적(Typical) 점화식**: `T(n) = a·T(n/b) + f(n)`.
- **정리**:
  1) `f(n) = O(n^{log_b a - ε})`  
  ⇒ `T(n) = Θ(n^{log_b a})`
  2) `f(n) = Θ(n^{log_b a} · log^k n)`   
  ⇒ `T(n) = Θ(n^{log_b a} · log^{k+1} n)`
  3) `f(n) = Ω(n^{log_b a + ε})`이고 정규성 조건  
  (예: `a·f(n/b) ≤ c·f(n)`, `c<1`) ⇒ `T(n) = Θ(f(n))`

### 2.5 병합 정렬(Merge Sort)
- **아이디어**: 반으로 분할 → 각 절반을 재귀 정렬 → 선형 시간 병합.
- **점화식**: `T(n) = 2T(n/2) + Θ(n)`, `T(1)=Θ(1)`.
- **의사코드(0-기반, 경계 명시)**
```cpp
#include <iostream>
#include <vector>

using namespace std;

void MERGE(vector<int>&A, int l, int m,  int r){

    int n1 = m - l + 1;
    int n2 = r - m;

    vector<int>L(n1, 0), R(n2, 0);


    for(int i = 0; i < n1; i++)
        L[i] = A[l + i];
    for(int i = 0; i < n2; i++)
        R[i] = A[m + 1 + i];

    int i = 0, j = 0;
    int k = l;

    while(i < n1 && j < n2){
        if(L[i] <= R[j]){
            A[k] = L[i];
            i++;
        } else {
            A[k] = R[j];
            j++;
        }
        k++;
    }
    while(i < n1){
        A[k] = L[i];
        i++;
        k++;
    }
    while(j < n2){
        A[k] = R[j];
        j++;
        k++;
    }

}

void MERGE_SORT(vector<int>&A, int l, int r){
    if(l >= r)
        return;
    int m = (l + r) >> 1;
    MERGE_SORT(A, l, m);
    MERGE_SORT(A, m + 1, r);
    MERGE(A, l, m, r);
}
```
- **MERGE 루프 불변식**: 루프 진입 시마다 `A[l..k-1]`은 `L[i..] ∪ R[j..]` 중 가장 작은 `(k-l)`개가 **정렬** 상태.
  - 초기화/유지/종료는 각각 공집합·최소 원소 선택·잔여 일괄 복사로 성립.
- **`O(n log n)` 증명(대입법)**:
  - 가정: `T(n) ≤ c n log n − d n` (충분히 큰 `n`).
  - 유도: `T(n) = 2T(n/2) + a n ≤ 2[c(n/2)log(n/2) − d(n/2)] + a n = c n log n − c n + a n − d n`.
  - `c ≥ a` 및 `d ≥ 0`로 두면 `T(n) ≤ c n log n`.
- **복잡도**: 시간 `Θ(n log n)`, 보조 배열 `Θ(n)`, 스택 `Θ(log n)`, 안정 정렬.

---

## 3. 수행 시간 특성화(Characterizing Running Times)

### 3.1 O, Ω, Θ 표기 방법 (비공식 요약)
- `O(g(n))`: 상한. **적당한 상수배 `g(n)`** 가 결국 `f(n)`을 덮는다.
- `Ω(g(n))`: 하한. **적당한 상수배 `g(n)`** 가 결국 `f(n)` 아래에 깐다.
- `Θ(g(n))`: 상·하한이 둘 다 성립(동일 성장률).
- `o(g(n))`: 임의의 작은 상수배 `c·g(n)`보다도 **궁극적으로 더 작음**.
- `ω(g(n))`: 임의의 작은 상수배 `c·g(n)`보다도 **궁극적으로 더 큼**.

### 3.2 점근적 표기: 공식적 정의(Formal Definitions)
- 모든 정의는 충분히 큰 `n ≥ n₀`에서 유효하며, `f(n), g(n) ≥ 0` 가정:
  - `f(n) ∈ O(g(n))` ⇔ `∃ c>0, n₀: 0 ≤ f(n) ≤ c·g(n)`
  - `f(n) ∈ Ω(g(n))` ⇔ `∃ c>0, n₀: 0 ≤ c·g(n) ≤ f(n)`
  - `f(n) ∈ Θ(g(n))` ⇔ `f(n) ∈ O(g(n))` 그리고 `f(n) ∈ Ω(g(n))`
  - `f(n) ∈ o(g(n))` ⇔ `∀ c>0, ∃ n₀: 0 ≤ f(n) < c·g(n)` (동치: `lim_{n→∞} f(n)/g(n) = 0`)
  - `f(n) ∈ ω(g(n))` ⇔ `∀ c>0, ∃ n₀: 0 ≤ c·g(n) < f(n)` (동치: `lim_{n→∞} f(n)/g(n) = ∞`)

### 3.3 표준 표기법과 흔히 쓰는 함수(Common Orders)
- **성장률 계층**(대표 예):
  - 상수 `<` 로그 `log n` `<` 다항의 일부 `n^ε (0<ε<1)` `<` 선형 `n` `<` 선형로그 `n log^k n` `<` 다항 `n^k` `<` 지수 `c^n (c>1)` `<` 계승 `n!`.
- **성질**:
  - 로그 밑은 상수 배만 다름: `log_a n = (log_b n)/(log_b a)`.
  - 다항 vs. 지수: 모든 `k`에 대해 `n^k = o(c^n)`.
  - 합의 지배: `f+g ∈ Θ(max{f,g})` (동차성 가정하 대개 성립).
  - 곱의 스케일: `c·f ∈ Θ(f)` (`c>0`).
  - 극한 판별: `lim f/g = 0,∞,θ(1)`에 따라 `o, ω, Θ` 판정.

---

## 4. 구현 팁 & 실수 포인트
- **경계/인덱스**: 오버플로우를 방지하여, 경계를 유심히 보고 설계.
- **안정성**: 병합에서 동등 비교는 `≤`.
- **작은 n 최적화**: 병합 정렬에서 작은 구간은 삽입 정렬로 스위치하면 상수 개선.
- **분석 습관**: 루프 불변식으로 올바름, 점화식으로 시간, 보조 메모리로 공간.

---

## 5. 예제 입력/출력 (선택)
- 병합 정렬 예: 입력 `[5,2,4,6,1,3]` → 출력 `[1,2,3,4,5,6]`.

---

## 6. 참고/출처
- Cormen, Leiserson, Rivest, Stein, **Introduction to Algorithms**, 4th ed., MIT Press, 2022. (개념·정의·구조 참조. 문장·그림 직접 복제 없음)
- 프로젝트 `NOTICE-CLRS.txt` 유지.

---

© 2025 park Jeyoung. Licensed under CC BY 4.0 — https://creativecommons.org/licenses/by/4.0/
Changes: 초판 작성(점근 표기 정의·분할정복·병합 정렬 포함).

